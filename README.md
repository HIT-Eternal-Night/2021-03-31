# 2021-03-31
今天复习指针，前面的基础打牢，不要急于求成！

1、指针的应用：
·函数返回运算的状态，结果通过指针返回。

常用的套路是让函数返回特殊的不属于有效范围内的值来表示出错，如-1和0。但当任何数值都可能是有效结果时，就得分开返回。
下面给出一段代码作为例子
#include<stdio.h>

int divide(int a, int b, int *result);

int main(int argc,char const*argv[])
{
	int a = 6;
	int b = 2;
	int c;
	if (divide(a,b,&c) ) 
	{
		printf("%d/%d = %d\n",a,b,c);
	}
	return 0;
}

//如果除法成功，返回1。否则返回0. 
int divide(int a, int b, int *result)
{
	int ret = 1;
	if (b == 0) ret = 0;
	else
	{
		*result = a/b;
	}
	return ret;
}

说明：运算正确要返回main函数，我们用指针将结果带回；如果在运算过程中出现不允许的错误，则用函数自身的返回值ret表达。

2、指针最常见的错误：定义了指针变量，还没有指向任何变量，就开始使用指针。

3、传入函数的东西：
传入普通变量，参数接收到的是值
传入指针，参数接收到的也是值，只不过这个值是地址，代表了外面的变量。
传入数组，实际上传入的是指针！
sizeof(a) == sizeof(int *)

但是对于这样的指针，我们可以用[]运算符来运算

以下四种函数原型是等价的：（仅在作为函数原型时等价）
int sum(int *ar,int n);
int sum(int *,int);
int sum(int ar[],int n);
int sum(int [],int);

数组变量是特殊的指针，数组变量本身表达地址。[]运算符可以对指针做，* 运算符也可以对数组做。
数组变量是const的指针，所以不能被赋值。即数组一旦被创建，就不能再去代表其他的数组了。

4、对于一个指针，我们有两个东西：指针本身的值（所指变量的地址）和指针指向的变量的值，这两者都可以施加const

一、指针是const
·表示一旦得到了某个变量的地址，就不能再指向其他变量。

如：int * const q = &i;  表明q的值不能被改变，也即q指向了i这个事实不能被改变，也就是q不能再指向别人了。他们之间的关系是永久的。
此时：*q  = 100;可以做，而q++;不能做。

二、所指是const
·表示不能通过这个指针（指针访问变量的方式）去修改那个变量（但这并不意味着也并不能使得那个变量成为const）

如：const int *p = &i; i可以被赋值、做运算，p也可以去指向其他的变量，但*p = 100;这件事情不可以做！
判断哪个被const了的标志是const在*前面还是后面
const在* 的前面表示不能通过指针去修改变量
const在* 的后面表示指针不能被修改

5、当要传递的参数的类型比地址大的时候，const int* 是常用的手段：既能用比较少的字节数传递值给参数，又能避免函数对外面的变量的修改。

6、给一个指针加1表示要让指针指向下一个变量。
int a[10];
int *p=a;
* (p+n)==a[n]
如果指针不是指向一片连续分配的空间，如数组，则这种运算没有意义

7、指针无论指向什么类型，所有的指针的大小都是一样的，因为都是地址。但是指向不同类型的指针是不能直接互相赋值的，这是为了避免用错指针

8、输入数据：
如果输入数据之前，先告诉你个数，然后再输入，同时要记录每个数据。C99可以用变量做数组定义的大小，C99之前呢？
我们用int *a = (int*)malloc(n*sizeof(int));

使用malloc需要#include<stdlib.h>   其函数原型为void*malloc(size_t size);

·向malloc申请的空间的大小是以字节为单位的，返回的结果是void*,需要类型转化为自己需要的类型。
·malloc之后一定要记得free()初地址，有借有还，再借不难！
